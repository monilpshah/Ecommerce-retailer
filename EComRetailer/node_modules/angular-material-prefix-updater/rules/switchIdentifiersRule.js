"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tslint_1 = require("tslint");
var path_1 = require("path");
var identifiers_1 = require("../typescript/identifiers");
var imports_1 = require("../typescript/imports");
var typescript_specifiers_1 = require("../material/typescript-specifiers");
var component_data_1 = require("../material/component-data");
var ts = require("typescript");
/** Message that is being sent to TSLint if an identifier still uses the outdated prefix. */
var failureMessage = 'Identifier can be switched from "Md" prefix to "Mat".';
/**
 * Rule that walks through every identifier that is part of Angular Material and replaces the
 * outdated prefix with the new one.
 */
var Rule = (function (_super) {
    __extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.applyWithProgram = function (sourceFile, program) {
        return this.applyWithWalker(new SwitchIdentifiersWalker(sourceFile, this.getOptions(), program));
    };
    return Rule;
}(tslint_1.Rules.TypedRule));
exports.Rule = Rule;
var SwitchIdentifiersWalker = (function (_super) {
    __extends(SwitchIdentifiersWalker, _super);
    function SwitchIdentifiersWalker() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** List of Angular Material declarations inside of the current source file. */
        _this.materialDeclarations = [];
        /** List of Angular Material namespace declarations in the current source file. */
        _this.materialNamespaceDeclarations = [];
        return _this;
    }
    /** Method that is called for every identifier inside of the specified project. */
    SwitchIdentifiersWalker.prototype.visitIdentifier = function (identifier) {
        // Store Angular Material namespace identifers in a list of declarations.
        // Namespace identifiers can be: `import * as md from '@angular/material';`
        this._storeNamespaceImports(identifier);
        // For identifiers that aren't listed in the className data, the whole check can be
        // skipped safely.
        if (!component_data_1.classNames.some(function (data) { return data.md === identifier.text; })) {
            return;
        }
        var symbol = identifiers_1.getOriginalSymbolFromNode(identifier, this.getTypeChecker());
        // If the symbol is not defined or could not be resolved, just skip the following identifier
        // checks.
        if (!symbol || !symbol.name || symbol.name === 'unknown') {
            console.error("Could not resolve symbol for identifier \"" + identifier.text + "\" " +
                ("in file " + this._getRelativeFileName()));
            return;
        }
        // For export declarations that are referring to Angular Material, the identifier should be
        // switched to the new prefix.
        if (imports_1.isExportSpecifierNode(identifier) && typescript_specifiers_1.isMaterialExportDeclaration(identifier)) {
            return this.createIdentifierFailure(identifier, symbol);
        }
        // For import declarations that are referring to Angular Material, the value declarations
        // should be stored so that other identifiers in the file can be compared.
        if (imports_1.isImportSpecifierNode(identifier) && typescript_specifiers_1.isMaterialImportDeclaration(identifier)) {
            this.materialDeclarations.push(symbol.valueDeclaration);
        }
        else if (this.materialDeclarations.indexOf(symbol.valueDeclaration) === -1 &&
            !this._isIdentifierFromNamespace(identifier)) {
            return;
        }
        return this.createIdentifierFailure(identifier, symbol);
    };
    /** Creates a failure and replacement for the specified identifier. */
    SwitchIdentifiersWalker.prototype.createIdentifierFailure = function (identifier, symbol) {
        var classData = component_data_1.classNames.find(function (data) { return data.md === symbol.name; });
        if (!classData) {
            console.error("Could not find updated prefix for identifier \"" + identifier.getText() + "\" in " +
                (" in file " + this._getRelativeFileName() + "."));
            return;
        }
        var replacement = this.createReplacement(identifier.getStart(), identifier.getWidth(), classData.mat);
        this.addFailureAtNode(identifier, failureMessage, replacement);
    };
    /** Checks namespace imports from Angular Material and stores them in a list. */
    SwitchIdentifiersWalker.prototype._storeNamespaceImports = function (identifier) {
        // In some situations, developers will import Angular Material completely using a namespace
        // import. This is not recommended, but should be still handled in the migration tool.
        if (imports_1.isNamespaceImportNode(identifier) && typescript_specifiers_1.isMaterialImportDeclaration(identifier)) {
            var symbol = identifiers_1.getOriginalSymbolFromNode(identifier, this.getTypeChecker());
            if (symbol) {
                return this.materialNamespaceDeclarations.push(symbol.valueDeclaration);
            }
        }
    };
    /** Checks whether the given identifier is part of the Material namespace. */
    SwitchIdentifiersWalker.prototype._isIdentifierFromNamespace = function (identifier) {
        if (identifier.parent.kind !== ts.SyntaxKind.PropertyAccessExpression) {
            return;
        }
        var propertyExpression = identifier.parent;
        var expressionSymbol = identifiers_1.getOriginalSymbolFromNode(propertyExpression.expression, this.getTypeChecker());
        return this.materialNamespaceDeclarations.indexOf(expressionSymbol.valueDeclaration) !== -1;
    };
    /** Returns the current source file path relative to the root directory of the project. */
    SwitchIdentifiersWalker.prototype._getRelativeFileName = function () {
        return path_1.relative(this.getProgram().getCurrentDirectory(), this.getSourceFile().fileName);
    };
    return SwitchIdentifiersWalker;
}(tslint_1.ProgramAwareRuleWalker));
exports.SwitchIdentifiersWalker = SwitchIdentifiersWalker;
//# sourceMappingURL=switchIdentifiersRule.js.map